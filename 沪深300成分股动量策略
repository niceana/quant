import pandas as pd
import numpy as np
import akshare as ak
import backtrader as bt
import matplotlib.pyplot as plt
import seaborn as sns
from datetime import datetime, timedelta
import warnings
import time
import tushare as ts
warnings.filterwarnings('ignore')


###策略描述
"""
基于动量因子的选股策略

1.获取沪深300指数历史数据作为基准。

2.计算每只股票的动量因子（过去60日收益率）。

3.每月末调仓：买入动量因子最高的10%的股票，等权重持有。

4.使用Backtrader进行回测。

5.绩效分析。"""

### 代码实现


# 设置中文显示
plt.rcParams['font.sans-serif'] = ['SimHei']
plt.rcParams['axes.unicode_minus'] = False

# 1. 数据获取函数
def fetch_data(start_date,end_date):
    """
    获取沪深300成分股和指数数据
    """
    print("正在获取数据...")
    
    pro = ts.pro_api()
    benchmark_data = pro.index_daily(ts_code='399300.SZ', start_date=start_date, end_date=end_date)
    benchmark_data = benchmark_data.sort_values(by='trade_date', ascending=True)
    benchmark_data['date'] = pd.to_datetime(benchmark_data['trade_date'])
    benchmark_data.set_index('date', inplace=True)
    benchmark_data = benchmark_data[['open','close']].copy()
    print(f"基准数据获取完毕,{benchmark_data.head()}")
    
    
    # 获取沪深300成分股列表
    pro = ts.pro_api()
    #start_date加一个月
    end_date1 = (datetime.strptime(start_date, '%Y%m%d') - timedelta(days=30)).strftime('%Y%m%d')
    hs300_constituents = pro.index_weight(index_code='399300.SZ', start_date='20200101', end_date='20200201')
    symbol_list = hs300_constituents['con_code'].tolist()
    print(f"沪深300成分股数量: {len(symbol_list)}")
    
    
    # 获取所有成分股数据
    all_stock_data = {}
    for symbol in symbol_list: 
        try:
            print(f"正在获取 {symbol} 数据...")
            stock_data = pro.daily(ts_code=symbol, start_date=start_date, end_date=end_date)
            #按照时间正序
            stock_data = stock_data.sort_values(by='trade_date', ascending=True)
            print(f"正在清洗 {symbol} 数据...")
            if not stock_data.empty:
                stock_data['date'] = pd.to_datetime(stock_data['trade_date'])
                stock_data.set_index('date', inplace=True)
                all_stock_data[symbol] = stock_data[['open','close']]
                print(f"已获取 {symbol} 数据")
        except:
            continue
    
    print("数据获取完成!")
    return all_stock_data, benchmark_data

# 2. 动量因子计算函数
def calculate_momentum_factor(stock_data, lookback_period=60):
    """
    计算每只股票的动量因子
    """
    momentum_data = {}
    
    for symbol, data in stock_data.items():
        # 计算过去N日的收益率
        data['return'] = data['close'].pct_change(lookback_period)
        momentum_data[symbol] = data
    
    return momentum_data

# 3. Backtrader策略定义
     

class MomentumStrategy(bt.Strategy):
    params = (
        ('lookback', 60),
        ('rebalance_days', 20),
        ('top_pct', 0.1),
    )

    def __init__(self):
        self.counter = 0
        self.inds = {}
        # 计算动量因子

        for d in self.datas:
            self.inds[d] = {}
            self.inds[d]['momentum'] = bt.indicators.ROC(d.close, period=self.params.lookback)
            print(self.inds[d]['momentum'])

    def notify_order(self, order):
        # 订单状态变化时调用
        if order.status in [order.Submitted, order.Accepted]:
            # 订单已提交/接受，但尚未执行
            return
            
        if order.status in [order.Completed]:
            if order.isbuy():
                print(f"买入订单执行: {order.data._name}, 数量: {order.executed.size}, 价格: {order.executed.price}, 成本: {order.executed.value:.2f}，佣金: {order.executed.comm:.2f}")
            elif order.issell():
                print(f"卖出订单执行: {order.data._name}, 数量: {order.executed.size}, 价格: {order.executed.price}, 成本: {order.executed.value:.2f}，佣金: {order.executed.comm:.2f}")
            
            # 更新投资组合信息
            print(f"现金: {self.broker.getcash():.2f}, 总价值: {self.broker.getvalue():.2f}")
        
        elif order.status in [order.Canceled, order.Margin, order.Rejected]:
            print(f"订单取消/拒绝: {order.data._name}, 状态: {order.getstatusname()}")

    def next(self):
        self.counter += 1
        
        # 20个交易日调仓一次
        if self.counter % self.params.rebalance_days != 0:
            return
        print(f"""============================================
              \n{self.counter}日, 开始新一轮选股...""")
        
        # 卖出当前持仓
        for i, d in enumerate(self.datas):
            if self.getposition(d).size:
                print(f"卖出 {d._name}, 持仓量 {self.getposition(d).size}")
                self.close(d)

        # 获取所有股票的动量值
        momentums = []
        valid_stocks = []
        
        for d in self.datas:
            if len(d) > self.params.lookback and not np.isnan(self.inds[d]['momentum'][0]):
                momentums.append(self.inds[d]['momentum'][0])
                valid_stocks.append(d)

        if not valid_stocks:
            print("没有有效的股票可供交易")
            return
        
        # 计算分位数
        momentums = np.array(momentums)
        print(f"动量值: {momentums}")
        threshold = np.percentile(momentums, 100 * (1 - self.params.top_pct))
        print(f"分位数: {threshold}")
        
        
        # 买入动量前10%的股票
        print(f"符合条件的股票数量: {len(valid_stocks)}")
        print(f"动量阈值: {threshold}")

        # 找出所有超过阈值的股票
        buy_stocks = []
        for d in valid_stocks:
            if self.inds[d]['momentum'][0] >= threshold:
                buy_stocks.append(d)
        print(len(buy_stocks))

        # 等权重分配资金买入
        if buy_stocks:
            portfolio_value = self.broker.getvalue()
            print(f"买入 {len(buy_stocks)} 只股票, 总投资金额: {portfolio_value * 0.9:.2f}")
            for d in buy_stocks:
                
                if d.close[0] > 0:  # 确保价格有效
                    size = portfolio_value * 0.9 / len(buy_stocks) / d.close[0]
                    self.buy(d, size=size)
                    print(f"买入 {d._name}, 价格: {d.close[0]:.2f}, 数量: {size:.2f}")    
        else:
            print("没有股票超过动量阈值")
        #清空动量值
        momentums = []
        valid_stocks = []
               



# 4. 回测与分析函数
def run_backtest(stock_data, benchmark_data):
    """
    运行回测并分析结果
    """
    cerebro = bt.Cerebro()
    
    # 添加策略
    cerebro.addstrategy(MomentumStrategy)
    
    # 添加股票数据
    for symbol, data in stock_data.items():
        # 确保数据格式正确
        data_df = bt.feeds.PandasData(
            dataname=data,
            datetime=None,  # 已经使用日期作为索引
            open=0, high=-1, low=-1, close=0, volume=-1, openinterest=-1
        )
        cerebro.adddata(data_df, name=symbol)
    
    # 添加基准数据
    start_time = datetime(2020, 1, 1)
    end_time = datetime(2023, 1, 1)
    benchmark_df = bt.feeds.PandasData(
        dataname=benchmark_data,
        datetime=None,  # 已经使用日期作为索引
        open=0, high=-1, low=-1, close=0, volume=-1, openinterest=-1
    )
    cerebro.adddata(benchmark_df, name='HS300')
    
    # 设置初始资金
    cerebro.broker.setcash(1000000.0)
    
    # 设置佣金
    cerebro.broker.setcommission(commission=0.001)  # 0.1%佣金
    
    # 添加分析器
    cerebro.addanalyzer(bt.analyzers.SharpeRatio, _name='sharpe')
    cerebro.addanalyzer(bt.analyzers.DrawDown, _name='drawdown')
    cerebro.addanalyzer(bt.analyzers.Returns, _name='returns')
    cerebro.addanalyzer(bt.analyzers.PyFolio, _name='pyfolio')
    
    print('初始资金: %.2f' % cerebro.broker.getvalue())
    
    # 运行回测
    results = cerebro.run()
 
    print('最终资金: %.2f' % cerebro.broker.getvalue())
    
    # 获取回测结果
    strat = results[0]
    
    # 计算年化收益率
    annual_return = strat.analyzers.returns.get_analysis()['rnorm100']
    
    # 计算夏普比率
    sharpe_ratio = strat.analyzers.sharpe.get_analysis()['sharperatio']
    
    # 计算最大回撤
    max_drawdown = strat.analyzers.drawdown.get_analysis()['max']['drawdown']
    
    # 打印绩效指标
    print("=== 策略绩效 ===")
    print("年化收益率: {:.2f}%".format(annual_return))
    print("夏普比率: {:.2f}".format(sharpe_ratio))
    print("最大回撤: {:.2f}%".format(max_drawdown))
                # 关闭所有 data 的绘图（即K线）
    for data in cerebro.datas:
        data.plotinfo.plot = False
    # 绘制净值曲线
    cerebro.plot(style='candlestick', volume=False)
    
    return {
        'annual_return': annual_return,
        'sharpe_ratio': sharpe_ratio,
        'max_drawdown': max_drawdown,
        'cerebro': cerebro
    }

# 5. 敏感性分析函数
def sensitivity_analysis(stock_data, benchmark_data, lookback_periods=[30, 60, 90, 120]):
    """
    对不同回看期进行敏感性分析
    """
    results = {}
    
    for period in lookback_periods:
        print(f"\n正在测试回看期: {period}天")
        
        # 计算动量因子
        momentum_data = calculate_momentum_factor(stock_data, lookback_period=period)
        
        # 运行回测
        result = run_backtest(momentum_data, benchmark_data)
        results[period] = result
    
    # 绘制敏感性分析结果
    periods = list(results.keys())
    returns = [results[p]['annual_return'] for p in periods]
    sharpes = [results[p]['sharpe_ratio'] for p in periods]
    drawdowns = [results[p]['max_drawdown'] for p in periods]
    
    fig, (ax1, ax2, ax3) = plt.subplots(3, 1, figsize=(10, 12))
    
    ax1.plot(periods, returns, 'o-')
    ax1.set_title('不同回看期的年化收益率')
    ax1.set_xlabel('回看期(天)')
    ax1.set_ylabel('年化收益率(%)')
    
    ax2.plot(periods, sharpes, 'o-')
    ax2.set_title('不同回看期的夏普比率')
    ax2.set_xlabel('回看期(天)')
    ax2.set_ylabel('夏普比率')
    
    ax3.plot(periods, drawdowns, 'o-')
    ax3.set_title('不同回看期的最大回撤')
    ax3.set_xlabel('回看期(天)')
    ax3.set_ylabel('最大回撤(%)')
    
    plt.tight_layout()
    plt.savefig('sensitivity_analysis.png', dpi=300)
    plt.show()
    
    return results

# 主函数
def main():
    # 获取数据
    stock_data, benchmark_data = fetch_data('20200101', '20231231')
    
    # 计算动量因子 (60天回看期)
    momentum_data = calculate_momentum_factor(stock_data, lookback_period=60)
    
    print(momentum_data)

    # 运行回测
    print("\n开始回测...")
    results = run_backtest(momentum_data, benchmark_data)
    
    # 进行敏感性分析
    print("\n开始敏感性分析...")
    sensitivity_results = sensitivity_analysis(stock_data, benchmark_data)
    
    # 输出总结
    print("\n=== 策略总结 ===")
    print("基于动量因子的选股策略在测试期间表现如下:")
    print(f"最佳回看期: {max(sensitivity_results, key=lambda x: sensitivity_results[x]['sharpe_ratio'])}天")
    print("该策略在A股市场表现出一定的超额收益，但伴随着较大的回撤。")
    print("建议进一步优化止损机制和仓位管理策略。")

if __name__ == '__main__':
    main()
