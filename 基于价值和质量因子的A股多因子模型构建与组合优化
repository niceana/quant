import akshare as ak
import pandas as pd
import numpy as np
import backtrader as bt
import datetime
import warnings
import tushare as ts
warnings.filterwarnings('ignore')

# 设置显示
pd.set_option('display.max_rows', 500)
pd.set_option('display.max_columns', 500)
pd.set_option('display.width', 1000)

# 1. 数据获取与预处理函数
def get_financial_data(stock_list, current_date):
    """
    获取指定年份和季度的A股基本面数据
    """
    print(f"正在获取 {current_date} 的 基本面数据...")
    # 获取估值指标数据
    pro = ts.pro_api()

    df = pro.daily_basic(ts_code='', trade_date=current_date, fields='ts_code,trade_date,turnover_rate,volume_ratio,pe,pb')
    df ['roe'] = df['pb']/df['pe']
    # 选取我们需要的字段并重命名
    factor_data = df[['ts_code', 'pe', 'pb','roe']].copy()
 
    # 过滤掉无效值
    factor_data = factor_data.replace([np.inf, -np.inf], np.nan)
    factor_data = factor_data.dropna()
    #只选需要的股票
    factor_data = factor_data[factor_data['ts_code'].isin(stock_list)]
    
    # 将数值型字符串转换为float
    for col in ['pe', 'pb', 'roe']:
        factor_data[col] = pd.to_numeric(factor_data[col], errors='coerce')
    
    factor_data = factor_data.dropna()
    return factor_data

# 2. 因子计算与综合评分
def calculate_factor_scores(factor_data):
    """
    计算每个因子的Z-Score并合成综合得分
    """
    df = factor_data.copy()
    
    # 定义因子方向 (1表示因子值越高越好，-1表示因子值越低越好)
    factor_directions = {'pe': -1, 'pb': -1, 'roe': 1}
    
    # 计算每个因子的Z-Score
    for factor in factor_directions.keys():
        mean_val = df[factor].mean()
        std_val = df[factor].std()
        if std_val == 0:  # 避免除零错误
            df[f'{factor}_z'] = 0
        else:
            df[f'{factor}_z'] = (df[factor] - mean_val) / std_val
        
        # 根据因子方向调整符号
        df[f'{factor}_z'] = df[f'{factor}_z'] * factor_directions[factor]
    
    # 计算综合得分 (等权加权)
    df['composite_score'] = df[['pe_z', 'pb_z', 'roe_z', ]].sum(axis=1)

    
    # 按综合得分排序
    df = df.sort_values('composite_score', ascending=False)
    
    return df

def get_stock_price_data(stock_list, start_date, end_date):
    """
    获取股票价格数据
    """
    all_price_data = {}
    for ts_code in stock_list:
        try:
            pro = ts.pro_api()
            stock_data  = pro.daily(ts_code=ts_code, start_date=start_date, end_date=end_date)
            #按照时间倒序
            stock_data = stock_data.sort_values(by='trade_date', ascending=True)
            if not stock_data.empty:
                stock_data['date'] = pd.to_datetime(stock_data['trade_date'])
                stock_data.set_index('date', inplace=True)
                stock_data = stock_data[['open','close']].copy()
                all_price_data[ts_code] = stock_data 

        except Exception as e:
            print(f"获取 {ts_code} 数据失败: {e}")
            continue
        
    return all_price_data


# 3. Backtrader策略
class FundamentalStrategy(bt.Strategy):
    params = (
        ('top_n', 10),  # 持有得分最高的前10只股票
        ('rebalance_months', 1),  # 每月调仓
    )

    def __init__(self):
        
        print(f"数据总长度: {self.datas[0].datetime.date(0)}")
        # 记录每只股票的当前权重
        self.target_weights = {}
        # 记录上一次调仓的月份
        self.last_rebalance_month = None
    def notify_order(self, order):
        # 订单状态变化时调用
        if order.status in [order.Submitted, order.Accepted]:
            # 订单已提交/接受，但尚未执行
            return
            
        if order.status in [order.Completed]:
            if order.isbuy():
                print(f"买入订单执行: {order.data._name}, 数量: {order.executed.size}, 价格: {order.executed.price}, 成本: {order.executed.value:.2f}，佣金: {order.executed.comm:.2f}")
            elif order.issell():
                print(f"卖出订单执行: {order.data._name}, 数量: {order.executed.size}, 价格: {order.executed.price}, 成本: {order.executed.value:.2f}，佣金: {order.executed.comm:.2f}")
            
            # 更新投资组合信息
            print(f"现金: {self.broker.getcash():.2f}, 总价值: {self.broker.getvalue():.2f}")
        
        elif order.status in [order.Canceled, order.Margin, order.Rejected]:
            print(f"订单取消/拒绝: {order.data._name}, 状态: {order.getstatusname()}")
    def prenext(self):
        self.next()
    def next(self):
        
        # 每月调仓一次
        # 获取当前日期
        current_date = self.datas[0].datetime.date(0)
        print(f"当前日期: {current_date}")
        # 如果是月初的第一个交易日，执行调仓
        if current_date.month != self.last_rebalance_month:
        # 记录本次调仓月份
            self.last_rebalance_month = current_date.month
       
            current_date = current_date.strftime('%Y%m%d')
            print(f"调仓日: {current_date}")
            # 调用get_financial_data获取当前时点的基本面数据
            #读取股票列表
            pro = ts.pro_api()
            #查询当前沪深300成分股的股票列表    
            stock_list = pro.index_weight(index_code='399300.SZ', start_date='20250101', end_date='20250201')
            stock_list = stock_list['con_code'].tolist()
            
            current_factor_data = get_financial_data(stock_list,current_date)
            
            # 计算因子得分
            scored_data = calculate_factor_scores(current_factor_data)
            # 选取得分最高的前10只股票
            top_n_stocks = scored_data.head(self.params.top_n)['ts_code'].tolist()
            print(f"选取得分最高的前{self.params.top_n}只股票: {top_n_stocks}")
            # 清空目标权重
            self.target_weights = {}

            # 计算目标权重
            for d in self.datas[1:]:
                if d._name in top_n_stocks:
                    self.target_weights[d] = 1.0 / len(top_n_stocks)
                else:
                    self.target_weights[d] = 0.0
                
            # 执行调仓
            self.rebalance_portfolio()

    def rebalance_portfolio(self):
        """根据目标权重调整仓位"""
        # 首先，卖出所有当前持仓但不在目标中的股票
        for data, pos in self.getpositions().items():
            if data not in self.target_weights or self.target_weights[data] == 0:
                if pos.size > 0:
                    self.close(data)
                    
        
        # 然后，调整到目标权重
        for data, target_weight in self.target_weights.items():
            if target_weight > 0:
                # 计算目标市值
                target_value = target_weight * self.broker.getvalue()*0.9
                # 计算目标股数
                current_price = data.close[0]
                if current_price > 0:  # 避免除零错误
                    target_size = target_value / current_price
                    #取整
                    target_size = int(target_size)
                    # 调整到目标股数
                    current_size = self.getposition(data).size
                    size_diff = target_size - current_size
                    print(f"提交买入：股票: {data._name}, 数量: {size_diff:.2f}, 价格: {current_price:.2f}")
                    if size_diff > 0:
                        self.buy(data, size=size_diff)
                    elif size_diff < 0:
                        self.sell(data, size=abs(size_diff))

# 4. 回测与分析
def run_backtest():
    cerebro = bt.Cerebro()
    
    # 添加策略
    cerebro.addstrategy(FundamentalStrategy)
    
    # 设置初始资金
    cerebro.broker.setcash(1000000.0)
    cerebro.broker.setcommission(commission=0.001)  # 0.1%手续费
    
  # 获取基准数据 (沪深300)
    start_date = '20210101'
    end_date = '20221231'
    pro = ts.pro_api()
    benchmark_data = pro.index_daily(ts_code='399300.SZ', start_date=start_date, end_date=end_date)
    benchmark_data = benchmark_data.sort_values(by='trade_date', ascending=True)
    benchmark_data['date'] = pd.to_datetime(benchmark_data['trade_date'])
    
    benchmark_data.set_index('date', inplace=True)
    benchmark_data1 = benchmark_data[['open','close']].copy()
    print(f"基准数据获取完毕,{benchmark_data1.head()}")

    
    # 添加到cerebro
    benchmark_feed = bt.feeds.PandasData(dataname=benchmark_data1, datetime=None)
    cerebro.adddata(benchmark_feed, name='HS300')
    
    # 获取股票列表 
    pro = ts.pro_api()

    #查询当前沪深300成分股的股票列表
    hs300_constituents = pro.index_weight(index_code='399300.SZ', start_date='20250101', end_date='20250201')
    stock_list = hs300_constituents['con_code'].tolist()
    
    print(f"沪深300成分股数量: {len(stock_list)}")
    #只选的股票

    print("股票列表获取完毕")
    
    # 获取股票价格数据并添加到cerebro
    price_data_dict = get_stock_price_data(stock_list, start_date, end_date)
    print("price_data_dict获取完毕")
    for ts_code, data in price_data_dict.items():
        data_feed = bt.feeds.PandasData(dataname=data,datetime=None)  # 已经使用日期作为索引)
        cerebro.adddata(data_feed, name=ts_code)
    
    
    # 添加分析器
    cerebro.addanalyzer(bt.analyzers.SharpeRatio, _name='sharpe')
    cerebro.addanalyzer(bt.analyzers.DrawDown, _name='drawdown')
    cerebro.addanalyzer(bt.analyzers.Returns, _name='returns')
    cerebro.addanalyzer(bt.analyzers.PyFolio, _name='pyfolio')
    
    print('初始资金: %.2f' % cerebro.broker.getvalue())
    
    # 运行回测
    results = cerebro.run()
    
    print('最终资金: %.2f' % cerebro.broker.getvalue())
    
    # 绩效分析
    strat = results[0]
    sharpe_ratio = strat.analyzers.sharpe.get_analysis()['sharperatio']
    max_drawdown = strat.analyzers.drawdown.get_analysis()['max']['drawdown']
    annual_return = strat.analyzers.returns.get_analysis()['rnorm100']
    
    print("=== 策略绩效 ===")
    print(f"年化收益率: {annual_return:.2f}%")
    print(f"夏普比率: {sharpe_ratio:.2f}")
    print(f"最大回撤: {max_drawdown:.2f}%")
            # 关闭所有 data 的绘图（即K线）
    for data in cerebro.datas:
        data.plotinfo.plot = False
    # 绘制净值曲线
    cerebro.plot()
    
    return {
        'annual_return': annual_return,
        'sharpe_ratio': sharpe_ratio,
        'max_drawdown': max_drawdown
    }

# 5. 主函数
def main():
    # 演示获取基本面数据
    stock_list = ['002938.SZ','601111.SH']
    factor_data = get_financial_data(stock_list,20241231)
    print("基本面数据示例:")
    print(factor_data.head())
    
    # 计算因子得分
    scored_data = calculate_factor_scores(factor_data)
    print("\n综合得分前10的股票:")
    print(scored_data[['ts_code', 'composite_score']].head(10))
    
    # 运行回测
    print("\n开始回测...")
    results = run_backtest()
    
    # 策略总结
    print("\n=== 策略总结 ===")
    print("多因子价值投资策略通过结合估值、质量和成长因子，")
    print("系统性地筛选被低估的优质公司。")
    print("回测结果显示该策略能够产生一定的超额收益。")
    print("实际应用中需要注意:")
    print("1. 财务数据的准确性和及时性")
    print("2. 因子权重的优化")
    print("3. 交易成本的影响")
    print("4. 风险控制措施的实施")

if __name__ == '__main__':
    main()
